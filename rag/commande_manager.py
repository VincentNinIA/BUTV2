#!/usr/bin/env python3
"""
Gestionnaire de commandes int√©gr√© avec gestion automatique des ruptures de stock
Combine le parser optimis√© avec le syst√®me de ruptures et l'email manager IA
"""
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import logging

from .optimized_search import OptimizedProductSearch, CommandeParser
from .gestionnaire_stock import GestionnaireStock, ResultatVerification
from .email_manager import EmailAIManager, ConfigurationEmail
from .settings import settings

logger = logging.getLogger(__name__)

@dataclass
class LigneCommandeAnalysee:
    """Une ligne de commande avec analyse compl√®te des ruptures"""
    # Informations de parsing
    id_produit: str
    designation: str
    quantite: int
    prix_unitaire: float
    prix_total: float
    parsing_success: bool
    
    # Informations produit
    product_found: bool
    product_info: Optional[Dict] = None
    
    # Analyse de rupture
    verification_rupture: Optional[ResultatVerification] = None
    
    # NOUVEAU : Alternatives du RAG
    alternatives_rag: List[Dict] = None
    
    def __post_init__(self):
        if self.alternatives_rag is None:
            self.alternatives_rag = []
    
    # Actions entreprises
    email_envoye: bool = False
    details_email: Optional[Dict] = None
    
    # Commentaires pour l'utilisateur
    commentaire_utilisateur: str = ""
    niveau_alerte: str = "info"  # info, warning, error

class CommandeManagerAvance:
    """Gestionnaire de commandes avanc√© avec gestion automatique des ruptures"""
    
    def __init__(self, excel_file_path: str = "data/Articles.xlsx"):
        """
        Initialise le gestionnaire de commandes avanc√©
        
        Args:
            excel_file_path: Chemin vers le fichier Excel des articles (source unique de donn√©es)
        """
        # Initialiser les composants avec la m√™me source de donn√©es
        self.search_engine = OptimizedProductSearch(excel_file_path)
        self.parser_commande = CommandeParser(self.search_engine)
        self.gestionnaire_stock = GestionnaireStock(excel_file_path)
        
        # Initialiser l'email manager si configur√©
        self.email_manager = None
        self._init_email_manager()
        
        logger.info("‚úÖ CommandeManagerAvance initialis√© avec source unique: Articles.xlsx")
    
    def _init_email_manager(self):
        """Initialise l'email manager si la configuration est disponible"""
        try:
            if settings.email_actif and settings.email_expediteur and settings.email_commercial:
                config_email = ConfigurationEmail(
                    email_expediteur=settings.email_expediteur,
                    mot_de_passe_expediteur=settings.email_mot_de_passe,
                    email_commercial=settings.email_commercial,
                    nom_commercial=settings.nom_commercial,
                    nom_entreprise=settings.nom_entreprise,
                    smtp_server=settings.smtp_server,
                    smtp_port=settings.smtp_port
                )
                
                self.email_manager = EmailAIManager(config_email)
                logger.info("‚úÖ Email manager configur√© et activ√©")
            else:
                logger.info("‚ÑπÔ∏è Email manager d√©sactiv√© (configuration incompl√®te)")
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Email manager non disponible: {str(e)}")
    
    def analyser_ligne_commande_complete(self, 
                                       ligne: str,
                                       date_commande: Optional[datetime] = None,
                                       date_livraison_souhaitee: Optional[datetime] = None) -> LigneCommandeAnalysee:
        """
        Analyse compl√®te d'une ligne de commande avec gestion des ruptures
        
        Args:
            ligne: Ligne de commande √† analyser
            date_commande: Date de la commande (d√©faut: aujourd'hui)
            date_livraison_souhaitee: Date de livraison souhait√©e par le client
            
        Returns:
            LigneCommandeAnalysee avec toutes les informations et actions entreprises
        """
        if date_commande is None:
            date_commande = datetime.now()
        
        # √âtape 1: Parser la ligne avec le syst√®me existant
        parsing_result = self.parser_commande.parse_ligne_commande(ligne)
        
        if not parsing_result['parsing_success']:
            return LigneCommandeAnalysee(
                id_produit="",
                designation="",
                quantite=0,
                prix_unitaire=0.0,
                prix_total=0.0,
                parsing_success=False,
                product_found=False,
                commentaire_utilisateur=f"‚ùå {parsing_result.get('erreur', 'Format non reconnu')}",
                niveau_alerte="error"
            )
        
        # √âtape 2: Cr√©er l'objet de base
        ligne_analysee = LigneCommandeAnalysee(
            id_produit=parsing_result['id_produit'],
            designation=parsing_result['designation'],
            quantite=parsing_result['quantite'],
            prix_unitaire=parsing_result['prix_unitaire'],
            prix_total=parsing_result['prix_total'],
            parsing_success=True,
            product_found=parsing_result['product_found'],
            product_info=parsing_result.get('product_info')
        )
        
        # √âtape 3: Si produit non trouv√©, pas besoin d'analyser les ruptures
        if not parsing_result['product_found']:
            ligne_analysee.commentaire_utilisateur = f"‚ùå Produit {ligne_analysee.id_produit} inexistant"
            ligne_analysee.niveau_alerte = "error"
            
            # Envoyer email pour produit inexistant si configur√©
            if self.email_manager:
                ligne_analysee.email_envoye, ligne_analysee.details_email = self._traiter_alerte_email_produit_inexistant(
                    ligne_analysee, date_commande
                )
            
            return ligne_analysee
        
        # √âtape 4: Analyser les ruptures avec le gestionnaire de stock
        try:
            verification = self.gestionnaire_stock.verifier_produit(
                product_id=ligne_analysee.id_produit,
                quantite_demandee=ligne_analysee.quantite,
                date_commande=date_commande,
                date_livraison_souhaitee=date_livraison_souhaitee
            )
            
            ligne_analysee.verification_rupture = verification
            
            # √âtape 5: G√©n√©rer commentaire utilisateur bas√© sur la v√©rification
            ligne_analysee.commentaire_utilisateur = self._generer_commentaire_utilisateur(verification)
            ligne_analysee.niveau_alerte = verification.niveau_alerte
            
            # √âtape 6: NOUVEAU - R√©cup√©rer les alternatives du RAG si probl√®me d√©tect√©
            alternatives_rag = []
            
            # ‚úÖ AM√âLIORATION: Logique plus fine pour le d√©clenchement du RAG
            # Ne d√©clencher le RAG que si c'est vraiment n√©cessaire
            declencher_rag = False
            
            if verification.type_disponibilite == 'rupture':
                # Rupture totale -> RAG n√©cessaire
                declencher_rag = True
                logger.info(f"üö® RAG d√©clench√©: Rupture totale pour {ligne_analysee.id_produit}")
                
            elif verification.type_disponibilite == 'avec_commande':
                # Stock avec r√©approvisionnement -> Analyser plus finement
                if verification.necessite_alerte_commercial:
                    # D√©lai d√©pass√© ou autre probl√®me -> RAG n√©cessaire
                    declencher_rag = True
                    logger.info(f"‚ö†Ô∏è RAG d√©clench√©: D√©lai d√©pass√© pour {ligne_analysee.id_produit}")
                else:
                    # Stock suffisant avec r√©approvisionnement dans les d√©lais -> RAG inutile
                    declencher_rag = False
                    logger.info(f"‚úÖ RAG non d√©clench√©: Stock suffisant avec r√©approvisionnement pour {ligne_analysee.id_produit}")
                    
            elif verification.niveau_alerte == 'error':
                # Autres erreurs critiques -> RAG n√©cessaire
                declencher_rag = True
                logger.info(f"‚ùå RAG d√©clench√©: Erreur critique pour {ligne_analysee.id_produit}")
            
            # D√©clencher le RAG seulement si n√©cessaire
            if declencher_rag:
                try:
                    # Utiliser la version optimis√©e pour r√©cup√©rer les alternatives
                    from .retrieval_optimized import fetch_docs_optimized
                    
                    # Utiliser le nom du produit trouv√© (pas l'ID de commande)
                    product_name = ligne_analysee.product_info.get('nom', ligne_analysee.designation) if ligne_analysee.product_info else ligne_analysee.designation
                    
                    rag_result = fetch_docs_optimized(
                        query=f"Alternative pour {product_name}",
                        product_id=product_name,  # Passer le nom du produit, pas l'ID de commande
                        required_qty=ligne_analysee.quantite,
                        prix_propose=ligne_analysee.prix_unitaire
                    )
                    
                    if rag_result and rag_result.get('alternatives'):
                        alternatives_rag = rag_result['alternatives']
                        logger.info(f"üîç RAG: {len(alternatives_rag)} alternatives trouv√©es pour {ligne_analysee.id_produit}")
                        
                        # ‚úÖ AM√âLIORATION: Ajouter les alternatives au commentaire (max 4 propos√©es)
                        if alternatives_rag:
                            nb_proposees = min(4, len(alternatives_rag))
                            ligne_analysee.commentaire_utilisateur += f" | üîÑ {nb_proposees} alternatives propos√©es"
                            
                except Exception as e:
                    logger.error(f"‚ùå Erreur r√©cup√©ration alternatives RAG: {str(e)}")
            else:
                logger.info(f"‚è≠Ô∏è RAG non d√©clench√© pour {ligne_analysee.id_produit} - Situation normale avec r√©approvisionnement")
            
            ligne_analysee.alternatives_rag = alternatives_rag  # Stocker pour usage ult√©rieur
            
            # √âtape 7: Traiter les alertes email si n√©cessaire (avec alternatives)
            if verification.necessite_alerte_commercial and self.email_manager:
                email_result = self.email_manager.traiter_alerte_rupture(verification, alternatives_rag)
                ligne_analysee.email_envoye = email_result.get('email_envoye', False)
                ligne_analysee.details_email = email_result
                
                if ligne_analysee.email_envoye:
                    ligne_analysee.commentaire_utilisateur += " | üìß Commercial alert√©"
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'analyse de rupture: {str(e)}")
            ligne_analysee.commentaire_utilisateur = f"‚ö†Ô∏è Erreur analyse stock: {str(e)}"
            ligne_analysee.niveau_alerte = "warning"
        
        return ligne_analysee
    
    def _generer_commentaire_utilisateur(self, verification: ResultatVerification) -> str:
        """G√©n√®re un commentaire utilisateur bas√© sur la v√©rification"""
        if verification.stock_suffisant and verification.niveau_alerte == 'info':
            return "‚úÖ Commande valid√©e"
        
        elif verification.type_disponibilite == 'avec_commande':
            if verification.niveau_alerte == 'warning':
                # ‚úÖ AM√âLIORATION: Commentaire plus explicite sur la d√©pendance au r√©approvisionnement
                date_str = ""
                if verification.date_livraison_estimee:
                    date_str = f" (livraison {verification.date_livraison_estimee.strftime('%d/%m/%Y')})"
                
                # Calculer les d√©tails de stock pour le commentaire
                produit = verification.produit
                stock_actuel = produit.quantite_stock - produit.commandes_a_livrer
                stock_a_recevoir = produit.stock_a_recevoir
                
                # Commentaire explicite sur la d√©pendance
                return f"‚ö†Ô∏è Livraison d√©pend du r√©approvisionnement - Stock actuel: {stock_actuel}, En commande: {stock_a_recevoir}{date_str}"
            
            elif verification.niveau_alerte == 'error':
                return "üö® D√©lai d√©pass√© - Contact commercial requis"
        
        elif verification.type_disponibilite == 'rupture':
            return "üö® RUPTURE DE STOCK - Alerte envoy√©e"
        
        elif verification.type_disponibilite == 'inexistant':
            return "‚ùå Produit inexistant - V√©rifier r√©f√©rence"
        
        return verification.message_principal
    
    def _traiter_alerte_email_produit_inexistant(self, 
                                               ligne: LigneCommandeAnalysee, 
                                               date_commande: datetime) -> tuple[bool, Optional[Dict]]:
        """Traite l'alerte email pour un produit inexistant"""
        try:
            donnees = {
                'product_id': ligne.id_produit,
                'quantite_demandee': ligne.quantite,
                'date_commande': date_commande.strftime('%d/%m/%Y')
            }
            
            email_genere = self.email_manager.generer_email_avec_ia('produit_inexistant', donnees)
            
            email_envoye = False
            if self.email_manager.config.email_commercial:
                email_envoye = self.email_manager.envoyer_email(
                    destinataire=self.email_manager.config.email_commercial,
                    objet=email_genere['objet'],
                    corps=email_genere['corps']
                )
            
            return email_envoye, {
                'email_genere': email_genere,
                'email_envoye': email_envoye,
                'type': 'produit_inexistant'
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erreur email produit inexistant: {str(e)}")
            return False, {'erreur': str(e)}
    
    def analyser_commande_complete(self, 
                                 commande_text: str,
                                 date_commande: Optional[datetime] = None,
                                 date_livraison_souhaitee: Optional[datetime] = None) -> Dict[str, Any]:
        """
        Analyse une commande compl√®te avec gestion automatique des ruptures
        
        Args:
            commande_text: Texte de la commande compl√®te
            date_commande: Date de la commande
            date_livraison_souhaitee: Date de livraison souhait√©e
            
        Returns:
            Dictionnaire avec analyse compl√®te et statistiques
        """
        lignes = [ligne.strip() for ligne in commande_text.split('\n') if ligne.strip()]
        
        resultats = {
            'lignes_analysees': [],
            'statistiques': {
                'total_lignes': len(lignes),
                'lignes_valides': 0,
                'lignes_avec_stock_ok': 0,
                'lignes_avec_rupture': 0,
                'lignes_avec_delai': 0,
                'emails_envoyes': 0,
                'total_quantite': 0,
                'total_prix': 0.0
            },
            'alertes_generees': [],
            'resum√©_commande': '',
            'date_analyse': datetime.now().strftime('%d/%m/%Y %H:%M:%S')
        }
        
        for i, ligne in enumerate(lignes):
            try:
                ligne_analysee = self.analyser_ligne_commande_complete(
                    ligne, date_commande, date_livraison_souhaitee
                )
                ligne_analysee.numero_ligne = i + 1
                
                resultats['lignes_analysees'].append(ligne_analysee)
                
                # Mettre √† jour les statistiques
                if ligne_analysee.parsing_success:
                    stats = resultats['statistiques']
                    stats['lignes_valides'] += 1
                    stats['total_quantite'] += ligne_analysee.quantite
                    stats['total_prix'] += ligne_analysee.prix_total
                    
                    if ligne_analysee.niveau_alerte == 'info':
                        stats['lignes_avec_stock_ok'] += 1
                    elif ligne_analysee.niveau_alerte == 'warning':
                        stats['lignes_avec_delai'] += 1
                    elif ligne_analysee.niveau_alerte == 'error':
                        stats['lignes_avec_rupture'] += 1
                    
                    if ligne_analysee.email_envoye:
                        stats['emails_envoyes'] += 1
                        resultats['alertes_generees'].append({
                            'ligne': i + 1,
                            'produit': ligne_analysee.id_produit,
                            'type': ligne_analysee.details_email.get('type', 'unknown') if ligne_analysee.details_email else 'unknown'
                        })
                
            except Exception as e:
                logger.error(f"‚ùå Erreur analyse ligne {i+1}: {str(e)}")
                # Cr√©er une ligne d'erreur
                ligne_erreur = LigneCommandeAnalysee(
                    id_produit="",
                    designation=ligne,
                    quantite=0,
                    prix_unitaire=0.0,
                    prix_total=0.0,
                    parsing_success=False,
                    product_found=False,
                    commentaire_utilisateur=f"‚ùå Erreur syst√®me: {str(e)}",
                    niveau_alerte="error"
                )
                ligne_erreur.numero_ligne = i + 1
                resultats['lignes_analysees'].append(ligne_erreur)
        
        # G√©n√©rer un r√©sum√©
        stats = resultats['statistiques']
        resultats['resum√©_commande'] = self._generer_resume_commande(stats)
        
        return resultats
    
    def _generer_resume_commande(self, stats: Dict[str, int]) -> str:
        """G√©n√®re un r√©sum√© textuel de l'analyse de commande"""
        total = stats['total_lignes']
        valides = stats['lignes_valides']
        ok = stats['lignes_avec_stock_ok']
        warnings = stats['lignes_avec_delai']
        errors = stats['lignes_avec_rupture']
        emails = stats['emails_envoyes']
        
        resume = f"üìä Analyse termin√©e: {valides}/{total} lignes valides"
        
        if ok == valides:
            resume += " | ‚úÖ Toutes les lignes sont OK"
        else:
            problemes = []
            if warnings > 0:
                problemes.append(f"{warnings} avec d√©lai")
            if errors > 0:
                problemes.append(f"{errors} en rupture")
            
            if problemes:
                resume += f" | ‚ö†Ô∏è Probl√®mes: {', '.join(problemes)}"
        
        if emails > 0:
            resume += f" | üìß {emails} alerte(s) envoy√©e(s)"
        
        return resume
    
    def obtenir_statistiques_globales(self) -> Dict[str, Any]:
        """Retourne les statistiques globales du syst√®me"""
        stats_search = self.search_engine.get_cache_stats()
        
        return {
            'search_engine': stats_search,
            'email_actif': self.email_manager is not None,
            'inventaire_produits': len(self.gestionnaire_stock.inventaire),
            'system_status': 'operational'
        }

def tester_commande_manager():
    """Test complet du gestionnaire de commandes avanc√©"""
    print("=== TEST DU GESTIONNAIRE DE COMMANDES AVANC√â ===\n")
    
    # CORRECTION: Utiliser uniquement le fichier Excel
    manager = CommandeManagerAvance()
    
    # Test avec une commande qui devrait avoir des ruptures
    print("üîç Test avec commande potentiellement probl√©matique:")
    commande_test = """76000 00420000 CAISSE US SC 450X300X230MM Qt√© 300 Prix : 0,7‚Ç¨
7600005 00000000 CAISSE US SC 200X140X140MM Qt√© 2000 Prix : 0,8‚Ç¨
76000 00330000 CAISSE US SC 200X150X90MM Qt√© 100 Prix : 0,9‚Ç¨"""
    
    # Date de livraison tr√®s proche (dans 3 jours)
    date_livraison_proche = datetime.now() + timedelta(days=3)
    
    resultats = manager.analyser_commande_complete(
        commande_test, 
        date_livraison_souhaitee=date_livraison_proche
    )
    
    print(f"üìã {resultats['resum√©_commande']}")
    print(f"üìä Statistiques:")
    for key, value in resultats['statistiques'].items():
        print(f"   ‚Ä¢ {key}: {value}")
    
    print(f"\nüìù D√©tail des lignes:")
    for ligne in resultats['lignes_analysees']:
        status_icon = "‚úÖ" if ligne.niveau_alerte == 'info' else "‚ö†Ô∏è" if ligne.niveau_alerte == 'warning' else "‚ùå"
        email_icon = " üìß" if ligne.email_envoye else ""
        print(f"   {status_icon} {ligne.id_produit}: {ligne.commentaire_utilisateur}{email_icon}")
    
    if resultats['alertes_generees']:
        print(f"\nüö® Alertes g√©n√©r√©es:")
        for alerte in resultats['alertes_generees']:
            print(f"   ‚Ä¢ {alerte['produit']}: {alerte['type']}")
    
    print(f"\nüìä Statistiques syst√®me:")
    stats_globales = manager.obtenir_statistiques_globales()
    for key, value in stats_globales.items():
        print(f"   ‚Ä¢ {key}: {value}")
    
    print("\n‚úÖ Test termin√© avec succ√®s !")

if __name__ == "__main__":
    tester_commande_manager() 